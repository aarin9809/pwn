# [자료구조] 스택 프레임(Stack Frame)

## C언어의 메모리 구조
* 코드영역
	* 코드 영역은 실행할 프로그램의 코드가 저장되는 영역.
	* 텍스트 영역 이라고도 불림.
	* CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리.

* 데이터 영역(메모리 크기는 컴파일 타임에 미리 결정)
	* 데이터 영역은 프로그램의 전역변수와 정적 변수가 저장됨.
	* 데이터 영역은 프로그램의 시작과 함께 할당, 프로그램이 종료되면 소멸.

* 스택 영역(메모리 크기는 컴파일 타임에 미리 결정)
	* 스택 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역임.
	* 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸.
	* 스택 영역에 저장되는 함수의 호출 정보는 **스택프레임** 이라고함.
	* 스택 영역은 push 동작으로 데이터를 저장하고, pop 동작으로 데이터를 인출.
	* LIFO 방식이므로 가장 늦게 저장된 데이터가 가장 먼저 인출됨.
	* 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됨.
* 힙 형역(런타임에 사용자가 결정하게 됨)
	* 메모리의 힙 영역은 사용자가 직접 관리할 수 있는 **그리고 해야만 하는** 메모리 영역.
	* 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨.
	* 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됨.

## malloc()
malloc() 함수는 프로그램이 실행 중일 때 사용자가 직접 힙 영역에 메모리를 할당하게 해주는 함수.

	void *malloc(size_t size);

malloc() 함수는 인자로 할당받고자 하는 메모리의 크기를 바이트 단위로 전달 받음.
malloc()은 전달받은 메모리 크기에 맞고, 아직 할당되지 않을 적당한 공간을 찾음.
이렇게 찾은 공간의 첫 번째 바이트를 가리키는 주소값을 반환.

만약 힙 영역에 할당할 수 있는 적당한 공간이 없다면 NULL 포인터를 반환.
주소값을 반홚받기 때문에 힙 영역에 할당된 메모리 공간으로 접근하려면 포인터를 사용해야함.
**malloc() 함수의 원형에서 볼 수 있는 size_t 타입은 부호 없는 정수!**

## free()
free() 함수는 힙 영역에 할당받은 메모리 공간을 다시 운영체제로 반환해주는 함수.

데이터 영역이나 스택 영역에 할당되는 메모리의 크기는 컴파일 타임에 결정되어, 프로그램에 실행되는 내내 고정됨.
하지만 메모리의 동적 할당으로 힙 영역에 생성되는 메모리의 크기는 런타임 내내 변환됨.
따라서 free() 함수를 사용하여 다 사용한 메모리를 해제하지 않으면, 메모리가 부족해지는 현상이 발생할 수 있음.
이처럼 사용이 끝난 메모리를 해제하지 않아서 메모리가 부족해지는 현상을 **메모리 누수** 라고 함.

	void free(void *ptr);

free() 함수는 인수로 해제하고자 하는 메모리 공간을 가리키는 포인터를 전달받음.
인수의 타입이 void 형포인터로 선언되어 있으므로, 어떠한 타입의 포인터라도 인수로 전달될 수 있음.

## calloc()

calloc() 함수는 malloc() 함수와 마찬가지로 힙 영역에 메모리를 동적으로 할당해주는 함수.
calloc() 함수와 malloc() 함수의 차지머은 인자의 개수임.
그리고 calloc() 함수는 메모리를 할당받은 후에 해당 메모리의 모든 비트 값을 전부 0으로 초기화.
calloc() 함수도 메모리를 동적으로 할당하기 때문에 free() 함수로 할당받은 메모리를 해제해야함.

	void *calloc(size_t nmemb, size_t size);
	void *calloc(size_t nmemb, size_t size);

calloc() 함수의 첫 번째 인수는 메모리 공간의 개수를, 두 번째 인수는 각 공간의 바이트  수를 나타냄.
따라서 calloc() 함수는 힙 영역에 size크기의 메모리 공간을 nmemb개 할당바들 수 있도록 요청함.

아래 두 코드는 동일한 기능을 수행함

		1. ptr_arr = (int*) malloc(arr_len * sizeof(int));
		2. ptr_arr = (int*) calloc(arr_len, sizeof(int));

## realloc()
realloc() 함수는 이미 할당된 메모리의 크기를 바꾸어 재할당할 때 사용하는 함수.

	void *realloc(void *ptr, size_t size);

realloc() 함수의 첫 번재 인수는 크기를 바꾸고자 하는 메모리 공간을 가리키는 포인터를 전달받음.
두 번째 인수로는 해당 메모리 공간에 재할당할 크기를 전달함.
만약 첫 번째 인수로 NULL이 전달되면 malloc() 함수와 같은 동작을 함.


## 스택 프레임
* 메모리의 스택 영역은 함수의 호출과 관계되는 지역 변수 및 매개변수가 저장되는 영역임.
* 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
* 스택 프레임이란 함수가 호출될 때, 그 함수만의 스택 영역을 구분하기 위해 생성되는 공간임. 이 공간에는 함수와 관계되는 지역 변수, 매개변수가 저장되며, 함수 호출 시 할당되며, 함수가 종료되면서 소멸된다.

함수가 호출될 때 스택에는 함수의 **매개변수**, 함수 호출이 끝난 뒤 돌아갈 **반화 주소값**, 함수 내부 **지역변수** 가 저장된다. 이렇게 스택 영역에 차례대로 저장되는 함수의 호출 정보를 스택 프레임 이라고 한다.

## 스택 프레임의 동작 방식
[예시 코드]

int main() {
	func1();
}

void func1(){
	func2();
}

void func2() {

}

0) 프로그램이 실행된다.
1) main() 함수가 실행되고, main() 함수의 스택 프레임이 스택에 저장된다.
2) func1() 함수가 실행되고, func1() 함수의 스택 프레임이 스택에 저장된다.
3) func2() 함수가 실행되고, func2() 함수의 스택 프레임이 스택에 저장된다.
4) func2() 함수의 모든 작업이 완료되어 반환되면 func2() 함수의 스택 프레임이 스택에서 제거된다.
5) func1() 함수의 모든 작업이 완료되어 반환되면 func1() 함수의 스택 프레임이 스택에서 제거된다.
6) main() 함수의 모든 작업이 완료되어 반환되면 main() 함수의 스택 프레임이 스택에서 제거된다.
7) 프로그램이 종료된다.

## 함수 프롤로그
함수 프롤로그란 함수가 호출되면 그 함수의 영역을 설정하기 위해 2개의 명령어를 사용한다.
* push ebp
* mov ebp, esp

ebp를 push 함으로써 caller 함수(자신을 호출한 함수)의 ebp를 스택에 저장한다. 그리고 esp를 ebp에 복사함으로써 esp를 ebp 주소로 설정한다. ebp는 함수의 기준점을 나타내므로, ebp를 기준으로 return address나 argc, argv 그리고 함수의 지역변수 등의 위치를 쉽게 알 수 있다.

1. ESP는 데이터가 들어가고 나갈 때마다 움직임.
* PUSH(데이터 들어감) - 스택의 끝자리에 데이터를 저장시키고, ESP를 다음 칸으로 변경함.
* POP(데이터 나감) - 스택의 끝자리 데이터를 빼내고, ESP를 앞 칸으로 변경함.

2. EBP를 통해 지금 사용중인 스택의 기준점 잡음.

3. 루틴이 새롭게 호출되면, 스택 상에 기존에 사용된 루틴의 정보(RET, SFP)를 저장함.
* RET - 루틴이 끝나고 진행해야 하는 명령이 기어된 곳.
* SFP -  날 호출한 상위 루틴의 EBP(스택의 기준).

#### Register
1. EIP(Extended Instruction Pointer) : CPU한테 다음 '할 일'을 알려줌
* '할 일' 이란? => CODE address
* CPU는 계산밖에 할 줄 모름. CPU는 EIP가 알려주는 메모리 주소에 있는 일을 가져다 실행한다. CPU가 그 일을 해내는 동안, EIP는 =1이 된다. -> 다음 할 일을 알려준다.

2. EBP : 지금 사용중인 스택의 **시작 지점**

3. ESP : 지금까지 사용한 스택의 **마지막 지점**

### 함수의 호출 단계
1. 함수가 사용할 매개 변수를 넣고 함수 시작 지점으로 점프한다. -> **함수 호출**
2. 함수 내에서 사용할 스택 프레임을 설정한다. -> **함수 프롤로그**
3. 함수의 내용을 수행한다. -> **함수 본체**
4. 수행을 끝내면 처음 호출한 지점으로 돌아가기 위해 스택을 복원한다. -> **함수 에필로그**

## 스택 프레임의 구조
* PUSH EBP : 함수 시작(EBP를 사용하기 전에 기존의 값을 스택에 저장)
* MOV EBP, ESP : 현재의 ESP(스택 포인터)를 EBP에 저장

* ... : 함수 본체. 여기서 ESP가 변경되더라도 ESP가 변경되더라도 EBP가 변경되지 않으므로 안전하게 로컬 변수와 파라미터를 엑세스할 수 있음.

* MOV ESP, EBP : ESP를 정리(함수 시작했을때의 값으로 복원 시킴)
* POP EBP : 리턴되기 전에 저장해 놓았던 원래 EBP 값으로 복원
* RETN : 리턴. 함수 종료

### 함수 프롤로그

* PUSH EBP : 함수 시작(EBP를 사용하기 전에 기존의 값을 스택에 저장)
* MOV EBP, ESP : 현재의 ESP(스택 포인터)를 EBP에 저장

함수 수행을 마치면 다시 제자리로 돌아가기 위해 EBP의 값을 스택 PUSH 하여 저장해놓는다.
EBP에 ESP를 저장해줌으로써 스택 프레임을 생성해준다.

### 함수 에필로그

* MOV ESP, EBP : ESP를 정리(함수 시작했을때의 값으로 복원 시킴)
* POP EBP : 리턴되기 전에 저장해 놓았던 원래 EBP 값으로 복원
* RETN : 리턴. 함수 종료

함수 수행을 마치면 호출을 했던 지점으로 돌아가기 위해 처음 함수가 시작되었을 때의 값으로 복원시킨다.
그 다음, 프롤로그에서 push 해놓았던 값을 다시 pop 하여 EBP에 넣어준다.


## Stack Overflow
앞서 함수의 재귀 호출이 무함히 반복되면, 해당 프로그램은 스택 오버플로우에 의하여 종료됨.
만약 재귀 호출이 무한히 반복되면, 재귀 호출에 의한 스택 프레임이 계속해서 쌓이게 됨.
이렇게 계속 쌓이게 되면 스택의 모든 공간을 다 차지하고 난 후 더 이상의 여유 공간이 없게 되는데 이때 또 다시 스택 프레임을 저장하게 되면, 해당 데이터는 스택 영역을 넘어가서 저장된다.

이렇게 해당 스택 영역을 넘어가도 데이터가 저장될 수 있으면, 해당 프로그램은 오동작을 하게 되거나 보안상 큰 취약점을 갖게 된다.
C언어에서는 실행 중인 프로그램에서 스택 오버플로우가 발생하면, 에러를 발생시키고 강제 종료를 시키게 된다.


----------------------------------------------------------------------------------------

# x86_64 Architecture

## Register
### 범용 레지스터
범용 레지스터의 주용도는 있으나, 그 외의 다양한 용도로 사용될 수 있는 레지스터임. x86_64에서 각각의 범용 레지스터는 8바이트를 저장할 수 있으며, 부호 없는 정수를 기준으로 2^64 -1 까지의 수를 나타낼 수 있음.

* rax(accumulator register) : 함수의 반환 값
* rbx(base regitster) : x64에서는 주된 용도 없음
* rcx(counter regitster) : 반복문의 반복 횟수, 각종 연산의 시행 횟수 
* rdx(data regitster) : x64에서는 주된 용도 없음
* rsi(source index) : 데이터를 옮길 때 원본을 가리키는 포인터
* rdi(destination index) : 데이터를 옮길 때 목적지를 가리키는 포인터
* rsp(stack pointer) : 사용중인 스택의 위치를 가리키는 포인터
* rbp(stack base pointer) : 스택의 바닥을 가리키는 포인터

* rbx(base regitster) : x64에서는 주된 용도 없음
* rcx(counter regitster) : 반복문의 반복 횟수, 각종 연산의 시행 횟수 
* rdx(data regitster) : x64에서는 주된 용도 없음
* rsi(source index) : 데이터를 옮길 때 원본을 가리키는 포인터
* rdi(destination index) : 데이터를 옮길 때 목적지를 가리키는 포인터
* rsp(stack pointer) : 사용중인 스택의 위치를 가리키는 포인터
* rbp(stack base pointer) : 스택의 바닥을 가리키는 포인터

### 세그먼트 레지스터
cs, ss, ds, es, fs, gs 총 6가지 세그먼트 레지스터가 존재하며, 각 레지스터의 크기는 16비트임. 세그먼트 레지스터는 x64로 아키텍쳐가 확장되며 용도에 큰 변화가 생긴 레지스터임.

### 명령 포인터 레지스터
프로그램은 일련의 기계어 코드들로 이루어져 있음. 이 중에서 CPU가 어느 부분의 코드를 실행할지 가리키는게 명령어 포인터 레지스터의 역할임. x64 아키텍처의 명령어 레지스터는 rip이며, 크기는 8바이트임.

### 플래그 레지스터
플래그 레지스터는 프로세서의 현재 상태를 저장하고 있는 레지스터임. 플래그 레지스터는 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현함.

### 레지스터 호환
x86_64 아키텍처는 IA-32의 64비트 확장 아키텍처이며, 호환이 가능함. IA-32에서 CPU의 레지스터들은 32비트 크기를 가지며, 이들의 명칭은 각각 eax, ebx, ecx, edx, esi, edi, esp, ebp였음. 호환성을 위해 이 레지스터들은 x86-64에서도 그대로 사용이 가능함.

앞서 말한 rax, rbx, rdx, rsi, rdi, rsp, rbp가 이들의 확장된 형태이며, eax, ebx 등은 확장된 레지스터의 하위 32비트를 가리킴. 예를 들어 eax는 rax의 하위 32비트를 의미함.

도한 마찬가지로 과거 16비트 아키텍처인 IA-16과의 호환을 위해 ax, bx, cx, dx, si, di, sp, bp는 eax, ebx, ecx, edx, esi, edi, esp, ebp의 하위 16비트를 가리킴

## 결론

* 범용 레지스터 : 주 용도는 있으나, 그 외의 용도로도 자유롭게 사용할 수 있는 레지스터.
* 세그먼트 레지스터 : 과거에는 메모리 세그멘테이션이나, 가용 메모리 공간의 확장을 위해 사용됐으나, 현재는 주로 메모리 보호를 위해 사용되는 레지스터.
* 플래그 레지스터 : CPU의 상태를 저장하는 레지스터
* 명령어 포인터 레지스터 : CPU가 실행해야할 코드를 가리키는 레지스터.

-------------------------------------------------------
<<<<<<< HEAD

# 리눅스 프로세스의 메모리 구조
## 세그먼트
* 리눅스에서는 프로세스의 메모리를 크게 5가지의 세그먼트로 구분함. 여기서 세그먼트란 **적재되는 데이터의 용도별로 메모리의 구획을 나눈 것**

크게 **코드 세그먼트**, **데이터 세그먼트**, **BSS 세그먼트**, **힙 세그먼트**, **스택 세그먼트**로 구분함.

운영체제가 메모리를 용도별로 나누면, 각 용도에 맞게 적절한 권한을 부여할 수 있다는 장점이 있음. 권한은 읽기, 쓰기, 실행이 존재하며,CPU는 메모리에 대해 권한이 부여된 행위만 할 수 있음.

예를 들어 데이터 세그먼트에는 프로그램이 실행되며 사용하는 데이터가 적재됨. CPU는 이곳의 데이터를 읽을 수 있어야 하며, 따라서 이 영역에는 읽기 권한이 부여됨. 반면 이 영역의 데이터는 실행 대상이 아니므로 실행 권한은 부여되지 않음.

'실행 중인 프로세스의 메모리가 5개의 영역으로 구분된다.' 정도로만 이해하면 됨.




### 코드 세그먼트
코드 세그먼트는 실행 가능한 기계 코드가 위치하는 영역으로 텍스트 세그먼트 라고도 불림.

프로그램이 동작하려면 코드를 실행할 수 있어야 하므로 이 세그먼트에는 읽기 권한과 실행 권한이 부여됨. 반면 쓰기 권한이 있으면 공격자가 악의적인 코드를 삽입하기가 쉬워지므로, 대부분의 현대 운영체제는 이 세그먼트에 쓰기 권한한을 제거함.

아래에서 정수 31337을 반환하는 main 함수가 컴파일 되면 554889e5b8697a00005dc3라는 기계 코드로 변환되는데, 이 기계 코드가 코드 세그먼트에 위치하게 됨.

	int main() { 
		return 31337; 
	}

### 데이터 세그먼트(역할 : 초기화된 전역 변수 또는 상수가 위치하는 영역 / 권한 : 읽기, 쓰기 or 읽기 전용 / 예: 초기화된 전역변수, 전역 상수)
데이터 세그먼트에는 컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들이 위치함. CPU가 이 세그먼트의 데이터를 읽을 수 있어야하므로, 읽기 권한이 부여됨.

* 데이터 세그먼트는 **쓰기가 가능한 세그먼트**와 **쓰기가 불가능한 세그먼트**로 다시 분류되는데, 쓰기가 가능한 세그먼트는 전역 변수와 같이 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치함. 이런 세그먼트는 data 세그먼트라고 부름.

* 쓰기가 불가능한 세그먼트에는 프로그램이 실행되면서 값이 변하면 안되는 데이터들이 위치함. 전역으로 선언된 상수가 여기에 포함됨. 이런 세그먼트를 rodata(read-only data) 세그먼트라고 부름.

아래는 데이터 세그먼트에 포함되는 여러 데이터의 유형임. 주의 깊게 살펴봐야할 변수는 str_ptr임. str_ptr은 "readonly" 라는 문자열을 가리키고 있는데, 이 문자열은 상수 문자열로 취급되어 rodata에 위치하며, 이를 가리키는 str_ptr은 전역변수로서 data에 위치함.


	int data_num = 31337;                       // data
	char data_rwstr[] = "writable_data";        // data
	const char data_rostr[] = "readonly_data";  // rodata
	char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata

	int main() { ... }

### BSS 세그먼트(역할 : 초기화되지 않은 데이터가 위치하는 영역 / 권한 : 읽기, 쓰기 / 예 : 초기화 되지 않은 전역 변수)
BSS 세그먼트는 컴파일 시점에 값이 정해지지않은 전역 변수가 위치하는 메모리 영역임. 여기에는 개발자가선언만 하고 초기화하지 않은 전역변수 등이 포함됨. 이 세그먼트의 메모리 영역은 프로그램이 시작될 때, 모두 0으로 값이 초기화됨. 이런 특성 때문에 C 코드를 작성할 때, 초기화되지 않은 전역 변수의 값은 0이 됨.

이 세그먼트에는 읽기 및 쓰기 권한이 부여됨.

아래 코드에서 초기화되지 않은 전역변수인 bss_data가 BSS 세그먼트에 위치하게 됨.

	int bss_data;

	int main() {
	  printf("%d\n", bss_data);  // 0
	  return 0;
	}

### 스택 세그먼트(역할 : 임시 변수가 저장되는 영역 / 권한 : 읽기, 쓰기 / 예 : 지역 변수, 함수 인자 등)
스택 세그먼트는 프로세스의 스택이 위치하는 영역임. 함수의 인자나 지역 변수와 같은 임시 변수들이 실행중에 여기에 저장됨.

스택 세그먼트는 스택 프레임이라는 단위로 사용됨. 스택 프레임은 함수가 호출될 때 생성되고, 반환될 때 해제 됨. 그런데 프로그램의 전체 실행 흐름은 사용자의 입력을 비롯한 여러 요인에 영향을 받음.

아래 코드에서 유저가 입력한 choice에 따라 call_true()가 호출될 수도, call_false()가 호출될 수도 있음.

	void func() {
	  int choice = 0;

	  scanf("%d", &choice);

	  if (choice)
	    call_true();
	  else
	    call_false();

	  return 0;
	}

따라서, 어떤 프로세스가 실행될 대, 이 프로세스가 얼마 만크의 스택 프레임을 사용하게 될 지를 미리 계산하는 것은 일반적으로 불간으함. 그래서 운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당해주고, 부족해 질 대마다 이를 확장해줌. 스택에 대해서 '아래로 자란다' 라는 표현을 종종 하는데, 이는 스택이 확장될 때, 기존 주소보다 '낮은 주소'로 확장되기 때문임.

이 영역에는 CPU가 자유롭게 값을 읽고 쓸 수 있어야 하므로, 읽기와 쓰기 권한이 부여됨.

위 코드에서는 지역변수 choice가 스택에 저장됨

### 힙 세그먼트(역할 : 실행중에 동적으로 사용되는 영역 / 권한 : 읽기, 쓰기 / 예 : mallo(), calloc() 등으로 할당 받은 메모리)
힙 세그먼트는 힙 데이터가 위치하는 세그먼트임. 스택과 마찬가지로 실행중에 동적으로 할당될 수 있으며, 리눅스에서는 스택 세그먼트와 반대 방향으로 자람. C언어에서 malloc(), calloc() 등을 호출해서 할당받는 메모리가 이 세그먼트에 위치하게 되며, 일반적으로 읽기와 쓰기 권한이 부여됨.

아래 예제 코드는 heap_data_ptr에 malloc()으로 동적 할당한 영역의 주소를 대입하고, 이 영역에 값을 씀. heap_data_ptr은 지역변수이므로 스택에 위치하며, malloc으로 할당받은 힙 세그먼트의 주소를 가리킴.

* 힙과 스택 세그먼트가 자라는 방향이 반대인 이유?

두 세그먼트가 동일한 방향으로 자라며, 연속된 메모리 주소에 각각 할당된다고 가정해보자. 이 경우, 기존의 힙 세그먼트를 모두 사용하고 나면, 이를 확장하는 과정에서 스택 세그먼트와 충돌하게 됨.

이를 쉽게 해결하기 위해 리눅스는 스택을 메모리의 끝에 위치시키고, 힙과 스택을 반대로 자라게 함. 이렇게 하면 힙과 스택은 메모리를 최대한 자유롭게 사용할 수 있으며, 충돌 문제로 부터도 비교적 자유롭게 됨.


-------------------------------------------------------------------------------------------------------------
# Assembly Language

* x64 어셈블리 언어는 동사에 해당하는 명령어(Operation Code, Opcode)와 목적어에 해당하는 피연산자(Operand)로 구성

ex) mov eax, 3
mov ; opcode(대입해라)
eax ; operand1(eax에)
3   ; operand2(3을)

## 명령 코드
1) 데이터 이동 : mov, lea
2) 산술 연산 : inc, dec, add, sub
3) 논리 연산 : and, or, xor, not
4) 비교 : cmp, test
5) 분기 : jmp, je, jg
6) 스택 : push, pop
7) 프로시져 : call, ret, leave
8) 시스템 콜 : syscall

### 피연산자
* 상수
* 레지스터
* 메모리

메모리 피연산자는 []으로 둘러싸인 것으로 표현되며, 앞에 크기 지정자 TYPE PTR이 추가될 수 있음. 여기서 타입에는 BYTE, WORD, DWORD, QWORD가 올 수 있으며, 각각 1바이트, 2바이트, 4바이트, 8바이트의 크기를 지정함.


QWORD PTR [0x8048000] : 0x8048000의 데이터를 8바이트만큼 참조

DWORD PTR [0x8048000] : 0x8048000의 데이터를 4바이트만큼 참조

WORD PTR [rax] : rax가 가리키는 주소에서 데이터를 2바이트 만큼 참조

#### 데이터 이동
mov dst, src : src에 들어있는 값을 dst에 대입
mov rdi, rsi : rsi 값을 rdi로 대입
mov QWORD PTR[rdi], rsi : rsi값을 rdi가 가키리는 주소에 대입

lea dst, src : src의 유효 주소를 dst에 저장
lea rsi,[rbx] : rbx를 rsi에 대입

#### 산술연산
add eax, 3 : eax += 3
sub eax, 3 : eax -= 3
sub ax, WORD PTR[rdi] : ax -= *(WORD *)rdi

inc eax : eax += 1
dec eax : eax -= 1

#### 논리연산

* and dst, src : dst와 src의 비트가 모두 1이면 1, 아니면 0

[Register]
eax = 0xffff0000
ebx = 0xcafebabe

[Code]
and eax, ebx

[Result]
eax = 0xcafe0000

* or dst, src: dst와 src의 비트 중 하나라도 1이면 1, 아니면 0
[Register]
eax = 0xffff0000
ebx = 0xcafebabe

[Code]
or eax, ebx

[Result]
eax = 0xffffbabe
 
* xor dst, src: dst와 src의 비트가 서로 다르면 1, 같으면 0
[Register]
eax = 0xffffffff
ebx = 0xcafebabe

[Code]
xor eax, ebx

[Result]
eax = 0x35014541

* not op: op의 비트 전부 반전
[Register]
eax = 0xffffffff

[Code]
not eax

[Result]
eax = 0x00000000

#### 비교
비교 명령어는 두 피연산자의 값을 비교하고, 플래그를 설정합니다.

* cmp op1, op2: op1과 op2를 비교
cmp는 두 피연산자를 빼서 대소를 비교. 연산의 결과는 op1에 대입하지 않음.

ex) 서로 같은 두 수를 빼면 결과가 0이 되어 ZF플래그가 설정되는데, 이후에 CPU는 이 플래그를 보고 두 값이 같았는지 판단할 수 있음.

[Code]
1: mov rax, 0xA
2: mov rbx, 0xA
3: cmp rax, rbx ; ZF=1

* test op1, op2: op1과 op2를 비교
test는 두 피연산자에 AND 비트연산을 취함. 연산의 결과는 op1에 대입하지 않음.

예를 들어, 아래 코드에서 처럼 0이된 rax를 op1과 op2로 삼아 test를 수행하면, 결과가 0이므로 ZF플래그가 설정됨. 이후에 CPU는 이 플래그를 보고 rax가 0이었는지 판단할 수 있음.

[Code]
1: xor rax, rax
2: test rax, rax ; ZF=1

#### 분기

* jmp addr: addr로 rip를 이동시킵니다.
[Code]
1: xor rax, rax
2: jmp 1 ; jump to 1

* je addr: 직전에 비교한 두 피연산자가 같으면 점프 (jump if equal)
[Code]
1: mov rax, 0xcafebabe
2: mov rbx, 0xcafebabe
3: cmp rax, rbx ; rax == rbx
4: je 1 ; jump to 1

* jg addr: 직전에 비교한 두 연산자 중 전자가 더 크면 점프 (jump if greater)
[Code]
1: mov rax, 0x31337
2: mov rbx, 0x13337
3: cmp rax, rbx ; rax > rbx
4: jg 1  ; jump to 1

#### 스택

* push val : val을 스택 최상단에 쌓음

rsp -= 8
[rsp] = val

* [Register]
rsp = 0x7fffffffc400

[Stack]
0x7fffffffc400 | 0x0  <- rsp
0x7fffffffc408 | 0x0

[Code]
push 0x31337

결과
[Register]
rsp = 0x7fffffffc3f8

[Stack]
0x7fffffffc3f8 | 0x31337 <- rsp 
0x7fffffffc400 | 0x0
0x7fffffffc408 | 0x0

* pop reg : 스택 최상단의 값을 꺼내서 reg에 대입

연산
rsp += 8
reg = [rsp-8]

[Register]
rax = 0
rsp = 0x7fffffffc3f8

[Stack]
0x7fffffffc3f8 | 0x31337 <- rsp 
0x7fffffffc400 | 0x0
0x7fffffffc408 | 0x0

[Code]
pop rax

결과
[Register]
rax = 0x31337
rsp = 0x7fffffffc400

[Stack]
0x7fffffffc400 | 0x0 <- rsp 
0x7fffffffc408 | 0x0

#### 프로시저
컴퓨터 과학에서 프로시저(Procedure)는 특정 기능을 수행하는 코드 조각을 말함. 프로시저를 사용하면 반복되는 연산을 프로시저 호출로 대체할 수 있어서 전체 코드의 크기를 줄일 수 있으며, 기능별로 코드 조각에 이름을 붙일 수 있게 되어 코드의 가독성을 크게 높일 수 있음.

프로시저를 부르는 행위를 호출(Call)이라고 부르며, 프로시저에서 돌아오는 것을 반환(Return)이라고 함. 프로시저를 호출할 때는 프로시저를 실행하고 나서 원래의 실행 흐름으로 돌아와야 하므로, call 다음의 명령어 주소(Return Address, 반환 주소)를 스택에 저장하고 프로시저로 rip를 이동시킴.

x64어셈블리 언어에는 프로시저의 호출과 반환을 위한 call, leave, ret 명령어가 있음

* call addr : addr에 위치한 프로시져 호출

연산
push return_address
jmp addr

[Register]
rip = 0x400000
rsp = 0x7fffffffc400 

[Stack]
0x7fffffffc3f8 | 0x0
0x7fffffffc400 | 0x0 <- rsp

[Code]
0x400000 | call 0x401000  <- rip
0x400005 | mov esi, eax
...
0x401000 | push rbp

* leave: 스택프레임 정리

연산
mov rsp, rbp
pop rbp

[Register]
rsp = 0x7fffffffc400
rbp = 0x7fffffffc480

[Stack]
0x7fffffffc400 | 0x0 <- rsp
...
0x7fffffffc480 | 0x7fffffffc500 <- rbp
0x7fffffffc488 | 0x31337 

[Code]
leave

[Register]
rsp = 0x7fffffffc488
rbp = 0x7fffffffc500

[Stack]
0x7fffffffc400 | 0x0
...
0x7fffffffc480 | 0x7fffffffc500
0x7fffffffc488 | 0x31337 <- rsp
...
0x7fffffffc500 | 0x7fffffffc550 <- rbp

* ret : return address로 반환

연산
pop rip

[Register]
rip = 0x401008
rsp = 0x7fffffffc3f8

[Stack]
0x7fffffffc3f8 | 0x400005    <- rsp
0x7fffffffc400 | 0

[Code]
0x400000 | call 0x401000
0x400005 | mov esi, eax
...
0x401000 | mov rbp, rsp  
...
0x401007 | leave
0x401008 | ret  <- rip

#### syscall
* 커널 모드는 운영체제가 전체 시스템을 제어하기 위해 시스템 소프트웨어에 부여하는 권한. 파일시스템, 입력/출력, 네트워크 통신, 메모리 관리 등 모든 저수준의 작업은 사용자 모르게 커널 모드에서 진행. 커널 모드에서는 시스템의 모든 부분을 제어할 수 있기 때문에, 해커가 커널 모드까지 진입하게 되면 시스템은 거의 무방비 상태가 됨.

* 유저 모드는 운영체제가 사용자에게 부여하는 권한. 브라우저를 이용하여 드림핵을 보거나, 유튜브를 시청하는 것, 게임을 하고 프로그래밍을 하는 것 등은 모두 유저 모드에서 이루어짐. 리눅스에서 루트 권한으로 사용자를 추가하고, 패키지를 내려 받는 행위 등도 마찬가지. 유저 모드에서는 해킹이 발생해도, 해커가 유저 모드의 권한까지 밖에 획득하지 못하기 때문에 해커로 부터 커널의 막강한 권한을 보호할 수 있습니다.

시스템 콜(system call, syscall)은 유저 모드에서 커널 모드의 시스템 소프트웨어에게 어떤 동작을 요청하기 위해 사용됨. 소프트웨어 대부분은 커널의 도움이 필요함. 예를 들어, 사용자가 cat flag를 실행하면, cat은 flag라는 파일을 읽어서 사용자의 화면에 출력해 줘야함. 그런데 flag는 파일 시스템에 존재하므로 이를 읽으려면 파일시스템에 접근할 수 있어야 함. 유저 모드에서는 이를 직접 할 수 없으므로 커널이 도움을 줘야함. 여기서, 도움이 필요하다는 요청을 시스템 콜 이라고 함. 유저 모드의 소프트웨어가 필요한 도움을 요청하면, 커널이 요청한 동작을 수행하여 유저에게 결과를 반환.

* syscall

요청: rax

인자 순서: rdi -> rsi -> rdx -> rcx -> r8 -> r9 -> stack

예제

[Register]
rax = 0x1   
rdi = 0x1   
rsi = 0x401000  
rdx = 0xb   

[Memory]
0x401000 | "Hello Wo"   
0x401008 | "rld"    

[Code]  
syscall 
=======
>>>>>>> f5713b9c261db23ab95e273125ef1df6da11b170
